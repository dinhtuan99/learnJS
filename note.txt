Six Phases of The Event Loop
Timers - executes callbacks using timers. If there are timers set to 0 ms or setImmediate(), they will run here. Incomplete timers will run in later iterations of the loop.
Pending - internal phase
Idle/Prepare - internal phase
Poll - process I/O callbacks
Check - execute any setImmediate() timers added in the Poll phase
Close - loop continues if there are more timers or I/O calls. If all timers and I/O calls are done, the loop closes and the process ends.

Version Package json
Pay special attention to the version listed. The format is as follows.

First number = major version
Second number = minor release
Third number = patch
The version states what was installed, but it also clarifies how it can be updated should you remove the node_modules and package-lock.json files and reinstall all dependencies with $ npm install.

The additional included characters (or lack thereof) tell npm how to maintain your dependencies.

* means that you'll accept all updates
^ means that you'll only accept minor releases
~ means that you'll only accept patch releases
>, >=, <=, < are also valid for saying you'll accept versions greater/less/equal to the listed version
|| allows you to combine instructions "prettier": "2.2.1 || >2.2.1 < 3.0.0" which says use prettier greater than 2.2.1 and less than version 3.0.0
You can also leave off a prefix and only accept the listed version

Typescripts
void - used as a return type when the function returns nothing

const myFunc = (student: string): void => {
  console.log(student);
};
never - used as a return type when the function will never return anything, such as with functions that throw errors or infinite loops

const myError = (err: string): never => {
  throw new Error(err); 
}
any - should be avoided. Used when the type of the item being typed can be anything

const myFunc = (student: any): any => {
  // do something
};
unknown - used when the type of the thing being typed is unknown. Used heavily for type assertion

const myFunc = (student: unknown): string => {
  // do something
}


Typescripts best practic
Use strong checks to prevent developer errors
One way to do this is to use noImplicitAny in tsconfig.json to prevent errors created by Typescript assuming Any type.
Turn on all strict checking by setting strict to true in your tsconfiig.json settings.
Pay attention to when to use Implicit vs Explicit typing
const

Typing: Implicit
Value is immutable so type can't be changed
let

Typing: Explicit
Value and type can be changed
Function with controlled inputs

Typing: Implicit
Output is controlled and code is simpler
Single-line arrow function

Typing: Implicit
Simpler code
Longer function

Typing: Explicit
Easier to read